# Recipe: Server-side OAuth2 Authentication flow with Next.JS API Routes.

This example shows how to use Headless Login for WPGraphQL to authenticate users on the server-side using one of the built-in OAuth2 providers.

We'll be using [`iron-session`](https://github.com/vvo/iron-session) to store the user's session data, but you can use any session management library you like.

## 1. Configure the Headless Login providers.

For more information on configuring the providers, see the [Settings Guide](..reference/settings.md).

You will need to set the Redirect URI to the [Next.js API route](https://nextjs.org/docs/api-routes/introduction) you want to use. You can create a different API route for each Login Client, or use a [catch-all route](https://nextjs.org/docs/api-routes/dynamic-api-routes#catch-all-api-routes) to handle all of them (what we'll be doing in this example).

## 2. Create the Login component.

In your headless app, you will need to create a Login component that sends the user to authenticate with the provider. You can choose to create the necessary `authorizationUrl` yourself, or use the one generated by the plugin for a DRYer solution.

E.g.

```jsx
// Login.jsx

// replace fetchAPI with whatever you're using to connect to WPGraphQL.
const data = await fetchAPI(
  `query LoginClients {
    loginClients {
      authorizationUrl
      name
      ...OtherLoginClientFields
    }
  }
  `
);

return (
  <>
    {
      data?.loginClients.map(
        (client) => (
          <a key={client.name} href={client.authorizationUrl}>
            { __( 'Login with: ', 'my-handle' ) + client.name }
          </a>
        )
      )
    }
  </>
);
```

When a user clicks the link, they will be directed to the Authentication provider. Once they authenticate, the Provider will send the authentication response data to the Callback `Redirect URI` we configured in [step 1](#1-configure-the-headless-login-providers)

## 3. Create the Authentication API route.

On your Callback API route (e.g. `/pages/api/auth/[provider].jsx` ), you grab the data from the request parameters, and feed it into your WPGraphQL login mutation.

```jsx
// pages/api/auth/[provider].jsx

// Our authentication call to WPGraphQL.
async function authenticate(provider, code, state) {
  const variables = {
    input: {
      provider,
      oauthResponse: {
        code
      }
    }
  };

  if ( state ) { // Not all providers send a state.
    variables.input.response.state = state;
  }

  // replace fetchAPI with whatever you're using to connect to WPGraphQL.
  const res = await fetchAPI(
    `mutation Login($input: LoginInput!) {
      login(input: $input) {
        authToken
        refreshToken
        user {
          ...UserFields
        }
      }
    }`,
    variables
  );

  if( res?.errors ) {
    throw new Error( res.errors[0].message );
  }

  return res?.data?.login;
}

async function sessionHandler(req, res) {
  const {
    code, // The Authorization code from the Provider
    state, // The State used to validate request authenticity
    provider, // the catch-all param.
  } = await req.query;

  // LoginProviderEnum is the generated type. You can always map this manually.
  const providerEnum = LoginProviderEnum[ provider.charAt( 0 ).toUpperCase() + provider.slice( 1 ) ];

  try {
    // ProviderEnum is the generated type. You can always map this manually.
    const data = await authenticate(providerEnum, code, state);

    // We're using iron session to store the session data in a secure httpOnly cookie, but you can use any session management library you like.
    const session = await getIronSession( req, res, ironOptions );
    const user = {
      isLoggedIn: true,
      ...data,
    };

    session.user = user;
    await session.save();

    // Let's send them somewhere.
    return res.redirect(307, '/dashboard');
  } catch (e) {
    // Do something with the error
    res.status(401).json({ error: e.message });

    // Or redirect them to the login page.
    return res.redirect(401, '/login');
  }
}

// And some more iron-session stuff:
export const ironOptions = {
  cookieName: 'wp-graphql-headless-login-session',
  password: process.env.SECRET_COOKIE_PASSWORD,
  cookieOptions: {
    // the next line allows to use the session in non-https environments like
    // Next.js dev mode (http://localhost:3000)
    secure: process.env.NODE_ENV === 'production',
  },
};

export default withIronSessionApiRoute(sessionHandler, ironOptions);
```

## 4. Create the Logout API route.

On your Logout API route (e.g. `/pages/api/logout.jsx` ), you can clear the session data.

Since we're using `iron-session`, we can just call `req.session.destroy()`.

```jsx

// pages/api/auth/logout.jsx

async function logoutHandler(req, res) {
  req.session.destroy();

  // Let's send back some JSON.
  return res.status(200).json({ isLoggedIn: false});
}

export default withIronSessionApiRoute(logoutHandler, ironOptions);
```

## 5. Create the Token Validation API route.

Headless Login uses JWT tokens for authentication. These tokens have an expiration time, and you will need to refresh them before they expire.

We can handle validating and refreshing the token on the server-side, so we don't expose these tokens to the client.

> Note: `req.session` is made available by `iron-session`. If you're using a different session management library, you'll need to use that library's API to access the session data.

```jsx
// pages/api/auth/user.jsx

// We'll use this function in our handler, to check if the authToken has expired.
function isTokenExpired( token ) : boolean {
  const decodedToken = decode( token );

  if ( ! decodedToken?.exp ) {
    return false;
  }

  // Expiry time is in seconds, but we need milliseconds so we do *1000
  const expiresAt = new Date( ( decodedToken.exp ) * 1000 );
  const now = new Date();

  return now >= expiresAt;
}

// Our refresh token call to WPGraphQL.
async function refreshAuthToken( refreshToken ) {
  const variables = {
    refreshToken,
  };

  // replace fetchAPI with whatever you're using to connect to WPGraphQL.
  const res = await fetchAPI(
    `mutation RefreshToken( $refreshToken: String! ) {
      refreshToken(
        input: {refreshToken: $refreshToken }
      ) {
        authToken
        refreshToken
        success
      }
    }`,
    {
      variables,
    },
  );

  if ( res?.errors ) {
    throw new Error( res?.errors[ 0 ].message );
  }

  return res?.data?.refreshToken;
}

async function userHandler(req, res) {
  const user = req.session?.user;

  // If the user doesn't have a refrsh token, they're not logged in.
  if ( ! user?.refreshToken ) {
    req.session.user = {
      ...user,
      isLoggedIn: false,
    };

    await req.session.save();
    return res.status( 401 ).send( req.session.user );
  }

  // If the user doesn't have an authToken, or it's expired, we'll refresh it.
  if ( ! user?.authToken || isTokenExpired( user.authToken ) ) {
    try {
      const { authToken, refreshToken, success } = await refreshTokens(
        user.refreshToken
      );

      user.authToken = authToken;
      user.refreshToken = refreshToken;

      req.session.user = {
        ...user,
        isLoggedIn: success,
      };
      
      await req.session.save();
      return res.status( success ? 200 : 401 ).send( req.session.user );
    } catch {
      // The token is invalid, but we have the stale data.
      req.session.user = {
        ...user,
        isLoggedIn: false,
      };

      await req.session.save();

      return res.status( 401 ).send( req.session.user );
    }
  }

  // If we get here, the user is logged in.
  return res.status( 200 ).send( req.session.user );
}

export default withIronSessionApiRoute(userHandler, ironOptions);
```

## 6. Use the authToken in your GraphQL requests.

Now that we have a way to authenticate with WPGraphQL, we can use the `authToken` in our GraphQL requests.

You can do this by fetching the `authToken` from the session data, and passing it in the `Authorization` header.

For example: here's the `fetchAPI` function we've been using until now.

```jsx
// utils/fetchAPI.js

export default async function fetchAPI(query, { variables } = {}) {
  const currentUser = await fetch('/api/auth/user').then(res => res.json());

  const headers = { 'Content-Type': 'application/json' };

  if( currentUser?.authToken ) {
    headers.Authorization = `Bearer ${currentUser.authToken}`;
  }

  try {
    const res = await fetch(process.env.WPGRAPHQL_URL, {
      method: 'POST',
      headers,
      body: JSON.stringify({
        query,
        variables,
      }),
    });

    const json = await res.json();

    if (json.errors) {
      console.error(json.errors);
      throw new Error('Failed to fetch API');
    }

    return json.data;

  } catch (e) {
    return {
      errors: [ e ],
    }
  }
}
```

The same approach can be taken with Apollo Client, or any other GraphQL client.

## 7. (Optional) Create some custom hooks.

We can create custom hooks to make it easier to handle authentication flows.

Here are a few common examples.

> Note: We are using the fetch API but you can use 'swr', or any other library you prefer.

### `useAuth`

```jsx
// hooks/useAuth.js

export function useAuth( {
  redirectTo = false, // An optional URL to redirect to.
  redirectIfFound = false, // If true, redirect if the user is already logged in.
} ) {
  const [ isAuthenticated, setIsAuthenticated ] = useState( false );
  const [ isReady, setIsReady ] = useState( undefined );

  useEffect( () => {
    ( async () => {
      const res = await fetch( '/api/auth/user', {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
      } );

      const user = await res.json();
      setIsAuthenticated( user?.isLoggedIn === true );
      setIsReady( true );
    } )();
  }, [] );

  useEffect( () => {
    if ( ! isReady || ! redirectUrl ) {
      return;
    }

    if (
      // If redirectIfFound is also set, redirect if the user was found
      ( redirectIfFound && isAuthenticated ) || ( ! redirectIfFound && ! isAuthenticated ) ) {
      setTimeout( () => {
        window.location.assign( redirectUrl );
      }, 200 );
    }
  }, [ isReady, isAuthenticated, redirectUrl, redirectIfFound ] );

  return { isReady, isAuthenticated };
}
```

### `useLogout`

```jsx
// hooks/useLogout.js

export function useLogout() {
  const [ error, setError ] = useState( undefined );
  const [ loading, setLoading ] = useState( false );

  async function logout( redirectUrl: string ) {
    setLoading( true );

    const logoutUrl = `/api/auth/logout`;

    const res = await fetch( logoutUrl, {
      method: 'POST',
    } );

    if ( ! res.ok ) {
      setError( res );
      setLoading( false );
      return;
    }

    if ( redirectUrl ) {
      window.location.assign( redirectUrl );
    } else {
      window.location.reload();
    }
    setLoading( false );
  }

  return {
    error,
    logout,
    loading,
  };
}
```
